#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')
const { checkbox, rawlist, input } = require('@inquirer/prompts')
const listTasks = require('./utils/listTasks')
const listGitDirs = require('./utils/listGitDirs')
const { reposDir, tasksDir } = require('./utils/constants')
const { getDefaultBranch } = require('./utils/git');

const askForRepo = async () => {
  const gitDirs = listGitDirs()
  if (gitDirs.length === 0) {
    console.log('No repositories found in the repos directory.')
    return null
  }

  const answer = await checkbox({
    message: 'Select repositories to checkout:',
    choices: gitDirs.map(dir => ({ name: dir, value: dir })),
    validate: (input) => input.length > 0 ? true : 'You must select at least one repository.'
  })

  return answer
}

const askForBranch = async (repos) => {
  const newBranch = {
    name: 'Create a new branch',
    value: 'new_branch'
  }

  const activeBranches = listTasks().map(task => ({
    name: task,
    value: task
  }))

  const answer = await rawlist({
    message: 'Select a task to perform on the repositories:',
    choices: [newBranch, ...activeBranches],
    validate: (input) => input ? true : 'You must select a task.'
  })

  if (answer === 'new_branch') {
    return { newBranch: true, repos }
  }

  return { newBranch: false, repos, folderName: answer, branchName: answer.replaceAll('.', '/') }
}

const askForNewBranchName = async (data) => {
  const type = await rawlist({
    message: 'Enter a name for the new branch:',
    choices: ['feature', 'bugfix'],
    validate: (input) => input ? true : 'You must enter a branch name.'
  })

  const taskNumber = await input({
    message: 'Enter the task number:',
    validate: (input) => input ? true : 'You must enter a task number.'
  })

  const subTaskNumber = await input({
    message: 'Enter the sub-task number (optional):',
    default: '000000',
    validate: (input) => input ? true : 'You must enter a sub-task number.'
  })

  const description = await input({
    message: 'Enter a description for the new branch:',
    validate: (input) => input ? true : 'You must enter a description.'
  })

  const nameBuilder = (type, taskNumber, subTaskNumber, description, separator = '/') => `${type}${separator}${taskNumber}${separator}${subTaskNumber}${subTaskNumber ? '-' : ''}${description}`

  const branchName = nameBuilder(type, taskNumber, subTaskNumber, description)
  const folderName = nameBuilder(type, taskNumber, subTaskNumber, description, '.')

  return { ...data, branchName, folderName }
}

const getDefaultBranches = async (variables) => {
  const { repos } = variables

  const defaultBranches = await Promise.all(repos.map(async (repo) => {
    const repoPath = path.join(reposDir, `${repo}.git`)
    if (!fs.existsSync(repoPath)) {
      console.error(`Error: The repository ${repo} does not exist in the repos directory.`)
      return null
    }
    const defaultBranch = await getDefaultBranch(repoPath)
    if (!defaultBranch) {
      console.error(`Error: Could not determine the default branch for ${repo}.`)
      return null
    }
    return { repo, defaultBranch }
  }))
    .then(branches => branches.filter(branch => branch !== null))
    .catch(error => {
      console.error('Error fetching default branches:', error.message)
      return []
    })

  if (defaultBranches.length === 0) {
    console.error('No valid repositories found or no default branches could be determined.')
    return null
  }

  const defaultBranchesDict = defaultBranches.reduce((acc, { repo, defaultBranch }) => {
    acc[repo] = defaultBranch
    return acc
  }, {})

  return {
    ...variables,
    defaultBranches: defaultBranchesDict
  }
}

const checkoutRepos = ({ repos, branchName, folderName, defaultBranches, ...rest }) => {
  repos.forEach((repo) => {
    const repoPath = path.join(reposDir, `${repo}.git`)
    const taskPath = path.join(tasksDir, folderName, repo)

    if (!fs.existsSync(repoPath)) {
      console.error(`Error: The repository ${repo} does not exist in the repos directory.`)
      return
    }

    if (!fs.existsSync(taskPath)) {
      fs.mkdirSync(taskPath, { recursive: true })
    }

    try {
      console.log(`Checking out ${repo} to ${taskPath} on branch ${branchName}...`)
      console.log(`Default branch for ${repo} is ${defaultBranches[repo]}.`)
      execSync(`git --git-dir=${repoPath} fetch origin ${defaultBranches[repo]}`, { stdio: 'inherit' })
      execSync(`git --git-dir=${repoPath} worktree add -b ${branchName} ${taskPath} ${defaultBranches[repo]}`, { stdio: 'inherit' })
      console.log(`Successfully checked out ${repo} to ${taskPath}.`)
    } catch (error) {
      console.error(`Failed to checkout ${repo}:`, error.message)
    }

  })
  return { repos, folderName, branchName, defaultBranches, ...rest }
}

const identifyRunner = (gitRepo) => {
  let runner = 'pnpm'
  if (
    fs.existsSync(path.join(gitRepo, 'yarn.lock')) ||
    fs.existsSync(path.join(gitRepo, 'lib', 'yarn.lock'))
  ) {
    runner = 'yarn'
  }
  return runner
}

const installDependencies = (variables) => {
  const { repos, folderName } = variables
  repos.forEach((repo) => {
    const taskPath = path.join(tasksDir, folderName, repo)
    const runner = identifyRunner(taskPath)
    console.log(`Installing dependencies for ${repo} at ${taskPath} with ${runner}.`)

    try {
      execSync(`${runner} install`, { cwd: taskPath, stdio: 'inherit' })
      console.log(`Dependencies installed for ${repo}.`)
    } catch (error) {
      console.error(`Failed to install dependencies for ${repo}:`, error.message)
    }

    try {
      execSync(`${runner} run prepare`, { cwd: taskPath, stdio: 'inherit' })
      console.log(`Hooks installed.`)
    } catch (error) {
      console.error(`Failed to install hooks for ${repo}:`, error.message)
    }

  })
  return variables
}

askForRepo()
  .then(askForBranch)
  .then((data) => {
    if (data.newBranch) {
      return askForNewBranchName(data)
    }
    return data
  })
  .then(getDefaultBranches)
  .then(checkoutRepos)
  .then(installDependencies)

